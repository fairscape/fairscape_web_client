import React, { useState, useCallback, useEffect, useRef } from "react";
import ReactFlow, {
  Controls as RFControls,
  Background,
  BackgroundVariant,
  useNodesState,
  useEdgesState,
  addEdge, // Keep addEdge if manual connections are desired, though onConnect blocks it
  Connection,
  NodeChange,
  EdgeChange,
  ReactFlowProvider,
  useReactFlow,
  Edge,
  Node, // Import Node type
  OnNodesChange, // Import OnNodesChange type
  OnEdgesChange, // Import OnEdgesChange type
  // useStoreApi, // Removed useStoreApi as per strategy change
} from "reactflow";
import "reactflow/dist/style.css";

import Legend from "./Legend";
import EvidenceNodeComponent from "./EvidenceNode";
import LoadingSpinner from "../common/LoadingSpinner";

import { EvidenceNode, EvidenceEdge, RawGraphData } from "../../types/graph";
import {
  getInitialElements,
  expandEvidenceNode,
  expandDatasetCollectionNode,
} from "../../utils/graphUtils";
import { getLayoutedElements } from "../../utils/layoutUtils";
import { findShortestPath } from "../../utils/pathfindingUtils"; // Import pathfinding utility
import styled, { css } from "styled-components"; // Import styled-components and css

// Styled Components for Viewer Layout and Highlighting CSS
const ViewerWrapper = styled.div`
  width: 100%;
  height: 550px;
  position: relative;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius};
  background-color: ${({ theme }) => theme.colors.surface};

  /* Add CSS rules for highlighting nodes and edges */
  .react-flow__node {
    /* Styles handled by EvidenceNode styled component itself */
    /* The classes 'path-highlight' and 'path-start-end' are applied to the node's root div */
  }

  .react-flow__edge {
    path {
      transition: stroke 0.2s ease, stroke-width 0.2s ease;
    }
    &.path-highlight {
      z-index: 1; /* Bring highlighted edges to front */
      path {
        stroke: #ff0072; /* Highlight color */
        stroke-width: 2.5; /* Make highlighted edges thicker */
      }
    }
    /* Add styles for edge types */
    &.edge-generated-by path {
      /* Example: style for 'generated by' */
    }
    &.edge-used-dataset path {
      /* Example: style for 'used dataset' */
    }
    /* ... other edge type styles if needed ... */
    &.edge-contains path {
      stroke-dasharray: 5 3; /* Dashed line for 'contains' edges */
    }
  }
`;

const LoadingOverlay = styled.div`
  position: absolute;
  inset: 0;
  background-color: rgba(255, 255, 255, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
`;

const LegendWrapper = styled.div`
  position: absolute;
  bottom: 10px;
  right: 10px;
  background-color: rgba(255, 255, 255, 0.9);
  padding: 8px;
  border-radius: 4px;
  border: 1px solid ${({ theme }) => theme.colors.border};
  z-index: 5;
  font-size: 12px;
`;

const SelectionIndicator = styled.div`
  position: absolute;
  top: 10px;
  left: 10px;
  background-color: rgba(0, 114, 255, 0.1);
  color: #0056b3;
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 12px;
  z-index: 5;
  border: 1px solid rgba(0, 114, 255, 0.3);
`;

const nodeTypes = { evidenceNode: EvidenceNodeComponent };

interface EvidenceGraphViewerProps {
  evidenceGraphData: RawGraphData | null;
}

// Define types for React Flow nodes and edges derived from your types
type RFNode = Node<EvidenceNode["data"]>;
type RFEdge = Edge<EvidenceEdge>;

const GraphRenderer: React.FC<EvidenceGraphViewerProps> = ({
  evidenceGraphData,
}) => {
  const [nodes, setNodes, onNodesChangeInternal] = useNodesState<
    RFNode["data"] // Specify the data type
  >([]);
  const [edges, setEdges, onEdgesChangeInternal] = useEdgesState<RFEdge>([]); // Specify the edge type
  const [isLoading, setIsLoading] = useState(false);
  // getNodes hook provides a snapshot of nodes. edges state variable is also a snapshot.
  const { fitView, project, getNodes } = useReactFlow(); // Keep getNodes for expansion logic
  const initialLayoutDone = useRef(false);
  const rootNodeIdRef = useRef<string | null>(null);

  // --- Pathfinding State ---
  const [pathSelectionStart, setPathSelectionStart] = useState<string | null>(
    null
  );
  const [highlightedPath, setHighlightedPath] = useState<{
    nodes: string[];
    edges: string[];
  }>({ nodes: [], edges: [] });

  // --- Utility for clearing highlighting ---
  const clearHighlighting = useCallback(() => {
    setHighlightedPath({ nodes: [], edges: [] });
    setPathSelectionStart(null);
  }, []);

  // --- Layout Application Function ---
  const applyLayout = useCallback(
    (
      // Ensure correct types are used for layout inputs
      layoutNodes: RFNode[],
      layoutEdges: RFEdge[],
      fit = false,
      onComplete?: () => void
    ) => {
      // Prevent layout if no nodes
      if (!layoutNodes || layoutNodes.length === 0) {
        console.warn("Layout skipped: No nodes provided.");
        setIsLoading(false); // Ensure loading is off
        if (onComplete) onComplete();
        return;
      }

      setIsLoading(true);
      // Clear highlighting whenever a layout is applied
      clearHighlighting();

      // Layout calculation happens in a timeout to not block the main thread
      // and potentially wait for React Flow's internal state to be ready.
      setTimeout(() => {
        try {
          console.log(
            `Applying layout to ${layoutNodes.length} nodes and ${layoutEdges.length} edges...`
          );
          // getLayoutedElements expects Node[] and Edge[]
          const { nodes: layoutedNodes, edges: layoutedEdges } =
            getLayoutedElements(
              layoutNodes as Node[], // Cast to Node[]
              layoutEdges as Edge[], // Cast to Edge[]
              "LR" // Or your preferred direction
            );

          console.log("Layout calculation complete. Updating state.");
          setNodes(layoutedNodes as RFNode[]); // Cast back to RFNode[] for state
          setEdges(layoutedEdges as RFEdge[]); // Cast back to RFEdge[] for state

          // Fit view after layout on initial load
          if (fit && !initialLayoutDone.current) {
            setTimeout(() => {
              const result = fitView({ padding: 0.15, duration: 300 });
              Promise.resolve(result)
                .then(() => {
                  initialLayoutDone.current = true;
                  console.log("FitView successful.");
                  // Removed the panBy logic here as it was complex and potentially problematic
                })
                .catch((err) =>
                  console.error("FitView promise rejected:", err)
                );
            }, 100); // Delay fitView slightly
          }
        } catch (error) {
          console.error("Layout failed:", error);
          // Fallback: If layout fails, just set nodes/edges without layout positions
          setNodes([...layoutNodes]); // Set original nodes (copy)
          setEdges([...layoutEdges]); // Set original edges (copy)
        } finally {
          setIsLoading(false);
          console.log("Layout process finished.");
          if (onComplete) setTimeout(onComplete, 50); // Call completion callback
        }
      }, 10); // Small delay before layout calculation starts
    },
    [setNodes, setEdges, fitView, clearHighlighting] // Add clearHighlighting to dependencies
  );

  // --- Effect for Initial Graph Loading ---
  useEffect(() => {
    if (evidenceGraphData) {
      initialLayoutDone.current = false; // Reset layout flag
      rootNodeIdRef.current = null; // Reset root node
      setIsLoading(true);
      clearHighlighting(); // Clear any highlighting when new data loads

      // Get initial nodes and edges (typically root + immediate neighbors)
      const { nodes: initialNodes, edges: initialEdges } =
        getInitialElements(evidenceGraphData); // Default depth is 2

      if (initialNodes.length > 0) {
        rootNodeIdRef.current = initialNodes[0].id;
        // Apply layout to initial elements and fit view
        applyLayout(initialNodes as RFNode[], initialEdges as RFEdge[], true); // Cast types
      } else {
        // Handle case with no initial nodes
        setNodes([]);
        setEdges([]);
        setIsLoading(false);
      }
    } else {
      // Clear graph if evidenceGraphData becomes null
      setNodes([]);
      setEdges([]);
      rootNodeIdRef.current = null;
      clearHighlighting();
      setIsLoading(false);
    }
  }, [evidenceGraphData, applyLayout, setNodes, setEdges, clearHighlighting]); // Add dependencies

  // --- Node Click Handler (Expansion and Pathfinding) ---
  const onNodeClick = useCallback(
    (event: React.MouseEvent, node: RFNode) => {
      // *** Handle Shift+Click for Path Selection ***
      if (event.shiftKey) {
        event.preventDefault(); // Prevent default React Flow selection/drag
        event.stopPropagation(); // Stop propagation to pane click

        if (!pathSelectionStart) {
          // Start selecting a path: set the start node
          setPathSelectionStart(node.id);
          // Immediately highlight the starting node
          setHighlightedPath({ nodes: [node.id], edges: [] });
        } else if (pathSelectionStart === node.id) {
          // Shift+clicked the start node again: cancel selection
          clearHighlighting();
        } else {
          // Shift+clicked an end node: find the path
          const endNodeId = node.id;

          // Get the *current* nodes and edges from state for pathfinding
          // Using getNodes() hook and edges state variable (matches original expansion logic access)
          const currentNodes = getNodes();
          const currentEdges = edges;

          // Use findShortestPath utility
          const pathResult = findShortestPath(
            pathSelectionStart,
            endNodeId,
            currentNodes as Node[], // Pass current nodes (cast)
            currentEdges as Edge[] // Pass current edges (cast)
          );

          if (pathResult) {
            // Path found: highlight the path nodes and edges
            const finalNodes = [...pathResult.pathNodeIds];
            // Ensure start and end nodes are explicitly included and in correct order
            if (!finalNodes.includes(pathSelectionStart))
              finalNodes.unshift(pathSelectionStart);
            if (!finalNodes.includes(endNodeId)) finalNodes.push(endNodeId);

            setHighlightedPath({
              nodes: finalNodes,
              edges: pathResult.pathEdgeIds,
            });
          } else {
            // No path found: clear highlighting
            console.warn(
              `No path found between ${pathSelectionStart} and ${endNodeId}.`
            );
            clearHighlighting();
          }
          // Reset selection state after finding or failing to find a path
          setPathSelectionStart(null);
        }
        return; // Exit the handler after handling shift+click
      }

      // *** Handle Regular Click for Expansion ***
      // If path selection is active (a start node is chosen),
      // a regular click should clear the selection instead of expanding.
      if (pathSelectionStart) {
        clearHighlighting(); // Clear the path selection
        event.stopPropagation(); // Stop propagation after clearing
        return;
      }

      // Clear any existing path highlighting on a regular node click before expanding
      // (unless it was just cleared above)
      if (
        highlightedPath.nodes.length > 0 ||
        highlightedPath.edges.length > 0
      ) {
        clearHighlighting();
      }

      // If the node is not expandable, do nothing more
      if (!node.data.expandable) {
        event.stopPropagation(); // Still stop propagation
        return;
      }

      // Get the *current* nodes from hook and edges state variable
      const currentNodes = getNodes();
      const currentEdges = edges;
      const clickedNodeObject = currentNodes.find((n) => n.id === node.id);

      if (!clickedNodeObject) {
        console.warn(
          `Clicked node ${node.id} not found in current nodes list.`
        );
        event.stopPropagation(); // Stop propagation
        return; // Should not happen if clicked, but safe guard
      }

      let newNodes: EvidenceNode[] = [];
      let newEdges: EvidenceEdge[] = [];
      let nodeDataUpdate: Partial<EvidenceNode["data"]> | null = null; // Use specific data type
      let needsLayout = false; // Flag to determine if layout is needed

      // Logic for expanding different node types
      if (clickedNodeObject.data.type === "DatasetCollection") {
        const expansionResult = expandDatasetCollectionNode(
          clickedNodeObject as EvidenceNode, // Cast type
          currentNodes as EvidenceNode[] // Pass current nodes (cast)
        );
        newNodes = expansionResult.newNodes;
        newEdges = expansionResult.newEdges;
        nodeDataUpdate = expansionResult.updatedCollectionData; // Update the collection node's data
        needsLayout = true; // Layout is needed when new items/edges are added
      } else if (!clickedNodeObject.data._expanded) {
        const expansionResult = expandEvidenceNode(
          clickedNodeObject as EvidenceNode, // Cast type
          currentNodes as EvidenceNode[] // Pass current nodes (cast)
        );
        newNodes = expansionResult.newNodes;
        newEdges = expansionResult.newEdges;

        nodeDataUpdate = {
          _expanded: true, // Mark node as expanded
          // Keep original expandable value unless explicitly setting to false later
        };

        // Check if layout is needed based on new elements
        needsLayout = newNodes.length > 0 || newEdges.length > 0;

        // If no new elements were added, the node might not be truly expandable (e.g., no neighbors)
        if (!needsLayout) {
          // If no layout is triggered, explicitly mark as non-expandable
          nodeDataUpdate.expandable = false;
        }
      } else {
        // Node is already expanded and not a collection
        // Do nothing, just stop propagation.
        event.stopPropagation();
        return;
      }

      // --- Calculate the *next* state before applying updates ---
      // Start with copies of the current state
      let nodesToUpdate = [...currentNodes];
      let edgesToUpdate = [...currentEdges]; // Use the state variable 'edges'

      // Update the clicked node's data in the copy
      if (nodeDataUpdate) {
        const nodeIndex = nodesToUpdate.findIndex(
          (n) => n.id === clickedNodeObject.id
        );
        if (nodeIndex > -1) {
          nodesToUpdate[nodeIndex] = {
            ...nodesToUpdate[nodeIndex],
            data: {
              ...nodesToUpdate[nodeIndex].data,
              ...nodeDataUpdate,
            } as RFNode["data"], // Ensure correct type for data spread
          };
        }
      }

      // Add new nodes, filtering duplicates against the new list
      newNodes.forEach((newNode) => {
        if (!nodesToUpdate.some((n) => n.id === newNode.id)) {
          nodesToUpdate.push(newNode as RFNode); // Cast type
        }
      });

      // Add new edges, filtering duplicates against the new list
      newEdges.forEach((newEdge) => {
        if (!edgesToUpdate.some((e) => e.id === newEdge.id)) {
          edgesToUpdate.push(newEdge as RFEdge); // Cast type
        }
      });
      // Ensure edges only connect nodes that exist in the nodesBeforeLayout set
      const nodeIdsToUpdateSet = new Set(nodesToUpdate.map((n) => n.id));
      edgesToUpdate = edgesToUpdate.filter(
        (edge) =>
          nodeIdsToUpdateSet.has(edge.source) &&
          nodeIdsToUpdateSet.has(edge.target)
      );

      // --- Apply Layout or just update state ---
      if (needsLayout) {
        // Perform layout on the calculated state (nodesToUpdate, edgesToUpdate)
        // applyLayout handles setting isLoading and calling setNodes/setEdges internally
        console.log("Expansion triggered layout. Calling applyLayout...");
        // Pass the *calculated* next state to the layout function
        applyLayout(nodesToUpdate, edgesToUpdate, false); // Don't fit view on expansion
      } else if (nodeDataUpdate) {
        // If no layout needed, but node data changed, just update nodes state directly
        console.log(
          "No new elements, but node data updated. Just setting nodes."
        );
        setNodes(nodesToUpdate);
        // Edges didn't change if needsLayout was false, so no need to setEdges
      } else {
        // This case should ideally not be reached if the logic is correct
        console.warn("Node click handler finished without updates or layout.");
      }

      event.stopPropagation(); // Stop propagation for regular clicks
    },
    [
      applyLayout, // Depend on the applyLayout function
      setNodes, // Depend on setNodes (needed for direct update when needsLayout is false)
      edges, // Depend on the 'edges' state variable (used for current edges)
      getNodes, // Depend on getNodes hook (used for current nodes)
      clearHighlighting, // Depend on utility function
      pathSelectionStart, // Depend on path selection state
      highlightedPath, // Depend on highlighted path state
      // Removed dependency on 'nodes' state variable as we use getNodes() or the calculated state
    ]
  );

  // --- Handlers for React Flow Internal Changes (Drag, Remove, etc.) ---
  const handleNodesChange: OnNodesChange = useCallback(
    (changes: NodeChange[]) => {
      // Only apply changes if not currently loading, or if they are drag changes
      const relevantChanges = changes.filter(
        (change) =>
          !isLoading || (change.type === "position" && change.dragging === true)
      );
      if (relevantChanges.length > 0) {
        onNodesChangeInternal(relevantChanges);
      }

      // If a removed node was part of a selection or path, clear highlighting
      changes.forEach((change) => {
        if (change.type === "remove") {
          if (
            highlightedPath.nodes.includes(change.id) ||
            pathSelectionStart === change.id
          ) {
            clearHighlighting();
          }
        }
      });
    },
    [
      isLoading,
      onNodesChangeInternal,
      highlightedPath,
      pathSelectionStart,
      clearHighlighting,
    ]
  );

  const handleEdgesChange: OnEdgesChange = useCallback(
    (changes: EdgeChange[]) => {
      onEdgesChangeInternal(changes);
      // If a removed edge was part of the highlighted path, clear highlighting
      changes.forEach((change) => {
        if (change.type === "remove") {
          if (highlightedPath.edges.includes(change.id)) {
            clearHighlighting();
          }
        }
      });
    },
    [onEdgesChangeInternal, highlightedPath, clearHighlighting]
  );

  // --- Prevent manual connections (as nodes aren't connectable manually) ---
  const onConnect = useCallback((params: Connection) => {
    console.log("Manual connection attempt blocked:", params);
    // setEdges((eds) => addEdge(params, eds)); // Keep this line if you *do* want manual connections
  }, []); // Added setEdges dependency if addEdge is uncommented

  // --- Clear path selection/highlighting when clicking on the empty canvas area ---
  const onPaneClick = useCallback(() => {
    clearHighlighting();
  }, [clearHighlighting]);

  // --- Apply highlight classes based on state before rendering ---
  // We need to modify the nodes and edges arrays *before* passing them to ReactFlow
  // in the render function to apply class names for styling.
  const styledNodes = nodes.map((node) => {
    const isPathNode = highlightedPath.nodes.includes(node.id);
    // Check if it's the first or last node in the highlighted path
    const isStartOrEndNode =
      isPathNode &&
      (node.id === highlightedPath.nodes[0] ||
        node.id === highlightedPath.nodes[highlightedPath.nodes.length - 1]);

    // Build the class name string, preserving any existing class names
    const highlightClasses = `${isStartOrEndNode ? "path-start-end" : ""} ${
      isPathNode ? "path-highlight" : ""
    }`.trim();
    const existingClassName = node.className ?? ""; // Get any class names already on the node
    const finalClassName = `${existingClassName} ${highlightClasses}`.trim();

    return {
      ...node,
      className: finalClassName, // Pass the combined class names to the node element
    };
  });

  const styledEdges = edges.map((edge) => {
    // Build the class name string, preserving any existing class names
    const highlightClasses = `${
      highlightedPath.edges.includes(edge.id) ? "path-highlight" : ""
    }`.trim();

    // Add edge type classes (e.g., for dashed lines on 'contains')
    const typeClasses =
      edge.label === "generated by"
        ? "edge-generated-by"
        : edge.label === "used dataset"
        ? "edge-used-dataset"
        : edge.label === "used software"
        ? "edge-used-software"
        : edge.label === "used sample"
        ? "edge-used-sample"
        : edge.label === "used instrument"
        ? "edge-used-instrument"
        : edge.label === "contains"
        ? "edge-contains" // Apply class for 'contains' edges
        : ""; // No specific class if label doesn't match

    const existingClassName = edge.className ?? "";
    const finalClassName =
      `${existingClassName} ${highlightClasses} ${typeClasses}`.trim();

    return {
      ...edge,
      className: finalClassName, // Pass the combined class names to the edge element
    };
  });

  return (
    <ViewerWrapper>
      {/* Loading Overlay */}
      {isLoading && (
        <LoadingOverlay>
          <LoadingSpinner />
        </LoadingOverlay>
      )}
      {/* Path Selection Indicator */}
      {pathSelectionStart && (
        <SelectionIndicator>
          Selecting path: Start node set (
          {/* Find display name from current nodes for indicator */}
          {/* Using 'nodes' state variable here is fine as it's for display during render */}
          {nodes.find((n) => n.id === pathSelectionStart)?.data?.displayName ||
            pathSelectionStart}
          ). Shift+click another node to complete.
        </SelectionIndicator>
      )}
      {/* The React Flow Canvas */}
      <ReactFlow
        nodes={styledNodes} // Pass the styled nodes with applied classes
        edges={styledEdges} // Pass the styled edges with applied classes
        onNodesChange={handleNodesChange} // Internal node change handler
        onEdgesChange={handleEdgesChange} // Internal edge change handler
        onConnect={onConnect} // Connection handler (currently blocked)
        nodeTypes={nodeTypes} // Register custom node components
        onNodeClick={onNodeClick} // Custom node click handler (expansion/pathfinding)
        onPaneClick={onPaneClick} // Custom pane click handler (clear highlighting)
        nodesDraggable={!isLoading} // Disable dragging while loading
        nodesConnectable={false} // Prevent manual connection dragging
        minZoom={0.1}
        maxZoom={4}
        attributionPosition="bottom-left"
        fitView={false} // Disable auto fitView, handled manually in applyLayout
        fitViewOptions={{ padding: 0.15 }} // Default options if manual fitView is used
      >
        {/* Background and controls */}
        <Background
          variant={BackgroundVariant.Dots}
          gap={15}
          size={0.5}
          color="#ccc"
        />
        <RFControls />
        {/* Legend */}
        <LegendWrapper>
          <Legend />
        </LegendWrapper>
      </ReactFlow>
    </ViewerWrapper>
  );
};

// Wrapper component needed for ReactFlowProvider to enable hooks like useReactFlow
const EvidenceGraphViewer: React.FC<EvidenceGraphViewerProps> = ({
  evidenceGraphData,
}) => {
  // ReactFlowProvider must wrap any components that use React Flow hooks
  return (
    <ReactFlowProvider>
      <GraphRenderer evidenceGraphData={evidenceGraphData} />
    </ReactFlowProvider>
  );
};

export default EvidenceGraphViewer;
